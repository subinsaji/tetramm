<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>synApps quadEM</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      quadEM Driver</h1>
    <h2>
      R7-0</h2>
    <h2>
      October 31, 2016</h2>
    <h2>
      Mark Rivers, University of Chicago</h2>
  </div>
  <h2>
    Contents</h2>
  <ul>
    <li><a href="#Overview">Overview</a></li>
    <li><a href="#Databases">Databases</a>
      <ul>
        <li><a href="#quadEM">quadEM.template</a></li>
        <li><a href="#TetrAMMAcquisitionModes">TetrAMM acquisition modes</a></li>
        <li><a href="#Plugins">Plugins: NDPluginStats, NDPluginStdArrays, NDFileNetCDF, NDPluginTimeSeries,
          NDPluginFFT</a></li>
        <li><a href="#fast_pid_control">fast_pid_control.db</a></li>
      </ul>
    </li>
    <li><a href="#Performance">Performance</a></li>
    <li><a href="#Common_Setup">Common Setup</a></li>
    <li><a href="#TetrAMM_Setup">TetrAMM Setup</a></li>
    <li><a href="#AHxxx_Setup">AH401 and AH501 series Setup</a></li>
    <li><a href="#NSLS_EM_Setup">NSLS Electrometer Setup</a></li>
    <li><a href="#APS_EM_Setup">APS Electrometer Setup</a></li>
  </ul>
  <h2 id="Overview">
    Overview</h2>
  <p>
    <b>quadEM</b> supports quad electrometers/picoammeters, typically used for photodiode-based
    x-ray beam position monitors, or split ion chambers. They can also be used for any
    low-current measurement that requires high speed digital input. There is support
    for several models:</p>
  <ol>
    <li>The AH401 series (AH401B, AH401D) and AH501 series (AH501, AH501C, AH501D) picoammeters
      originally designed by <a href="http://ilo.elettra.trieste.it/index.php?page=_layout_prodotto&amp;id=54&amp;lang=en">
        Synchrotron Trieste (elettra)</a>. They are now sold commerically by <a href="http://www.caenels.com/products">
          CAENels</a>. These devices communicate using TCP or UDP over 100 Mbit/s Ethernet
      or high-speed serial. They provide 4-channel current measurements at up to 6510
      Hz (AH501 series) or 1000 Hz (AH401 series).</li>
    <li>The TetrAMM picoammeter sold by <a href="http://www.caenels.com/products">CAENels</a>.
      This device communicates using TCP/IP over 1 Gbit/s Ethernet. It provides 4-channel
      current measurements at up to 20 kHz.</li>
    <li>The NSLS Quad Electrometer (called NSLS_EM in this document). This device consists
      of a 4-channel digital electrometer unit with Ethernet communication. The device
      provides 4-channel current measurements at up to 2500 Hz. The <a href="http://sydortechnologies.com/files/Data-Sheet-SI-EP-B4.pdf">
        Sydor SI-EP-B4</a> is based on this design and is software comptabible.</li>
    <li>The Quad Electrometer built by Steve Ross from the APS (called APS_EM in this
      document). This device consists of a 4-channel digital electrometer unit and 2 VME
      boards. The device provides 2 readings per diode at up to 813 Hz. This device appears
      to no longer be in use on any APS beamlines, so the support is now deprecated and
      will be removed in a future release.</li>
  </ol>
  <p>
    The AH401 series, NSLS_EM, and APS_EM are based on the same principle of an op-amp
    run as a current amplifier with a large feedback capacitor, and a high resolution
    ADC. The AH501 series and TetrAMM are based on a transimpedance input stage for
    current sensing, combined with analog signal conditioning and filtering stages.
    The AH501C, AH501D, and TetrAMM have an integrated programmable bias supply.</p>
  <p>
    The <b>quadEM</b> software includes asyn drivers that provide support for the following:</p>
  <ul>
    <li>Analog input records using the NDPluginStats plugin from the synApps <a href="areaDetector.html">
      areaDetector</a> module. This provides digitally averaged readings of the current,
      sum, difference and position at speeds that are determined by the AveragingTime
      record described below. The quadEM drivers do the callbacks on the asynGenericPointer
      interface for NDArray objects required to use the areaDetector plugins. The NDPluginStats
      module is used to compute the averaged readings. It also provides additional statistics
      including standard deviation, min, max, and a histogram of values.</li>
    <li>The NDPluginStats provide time-series of the statistics. These can be used to
      for on-the-fly data acquisition applications, where the meter is triggered by an
      external pulse source, such as one derived from a motor motion.</li>
    <li>One could also use the standard asynFloat64 device support with ai records and
      scan=I/O Intr, in which case the record would update with every reading from the
      device. This is likely to overwhelm the EPICS IOC if the electrometer is run at
      very fast sampling times.</li>
    <li>Streaming data to disk at the full rate from the device. This is done using the
      file plugins from areaDetector.</li>
    <li>Time series data (like a digital scope) of the current, sum, difference and position
      at speeds up to 20000 Hz (TetrAMM), 6510 Hz (AH501 series), 1000 Hz (AH401 series)
      2500 Hz (NSLS_EM), or 813 Hz (APS_EM). The data is available in standard EPICS waveform
      records, using the <a href="NDPluginTimeSeries.html">NDPluginTimeSeries plugin</a>
      from areaDetector/ADCore. The time per point can be greater, in which case it does
      averaging.</li>
    <li>FFTs of the time series data, providing the power spectrum of each signal as another
      EPICS waveform record. This uses the <a href="NDPluginFFT.html">NDPluginFFT plugin</a>
      from areaDetector/ADCore.</li>
    <li>epid (fast feedback). This provides fast feedback via an asyn D/A converter (e.g.
      dac128V), also at speeds up to 20000 Hz, 6510 Hz, 1000Hz, 2500 Hz, or 813Hz. If
      it is run slower it does signal averaging. This support is provided in the synApps
      <a href="http://www.aps.anl.gov/bcda/synApps/std/std.html">std</a> module. The quadEM
      drivers do the callbacks on the asynFloat64 interface required to use the epid fast
      feedback device support.</li>
  </ul>
  <p>
    The following manuals provide detailed information on these devices:</p>
  <ul>
    <li>APS electrometer: <a href="Electrometer_Users_Guide_01_22_2007.pdf">Electrometer
      Users Guide</a></li>
    <li>AH401B electrometer: <a href="AH401B_UsersManual_V1.0.pdf">AH401B Users Manual</a></li>
    <li>AH401D electrometer: <a href="AH401D_UsersManual_V1.2.pdf">AH401D Users Manual</a></li>
    <li>AH501C electrometer: <a href="AH501C_UsersManual_V1.0.pdf">AH501C Users Manual</a></li>
    <li>AH501D electrometer: <a href="AH501D_UsersManual_V1.3.pdf">AH501D Users Manual</a></li>
    <li>TetrAMM electrometer: <a href="TetrAMM_UsersManual_V1.5.pdf">TetrAMM Users Manual</a></li>
  </ul>
  <p>
    The support is based on <a href="http://cars.uchicago.edu/software/epics/areaDetectorDoc.html#asynNDArrayDriver">
      asynNDArray driver</a> from <a href="http://cars.uchicago.edu/software/epics/areaDetectorDoc.html">
        areaDetector</a>, which in turn is based on <a href="http://www.aps.anl.gov/epics/modules/soft/asyn/R4-29/asynPortDriver.html">
          asynPortDriver</a>. It consists of a base class <a href="quadEMDoxygenHTML/classdrv_quad_e_m.html">
            (drvQuadEM.cpp)</a> which is device-independent. There are device-dependent
    classes for the TetrAMM <a href="quadEMDoxygenHTML/classdrv_tetr_a_m_m.html">(drvTetrAMM.cpp)</a>,
    AH401 and AH501 series <a href="quadEMDoxygenHTML/classdrv_a_hxxx.html">(drvAHxxx.cpp)</a>
    NSLS electromater <a href="quadEMDoxygenHTML/classdrv_n_s_l_s__e_m.html">(drvNSLS_EM.cpp)</a>,
    and the APS electrometer <a href="quadEMDoxygenHTML/classdrv_a_p_s___e_m.html">(drvAPS_EM.cpp)</a>.
  </p>
  <p>
    The quadEM driver works as follows:</p>
  <ul>
    <li>The data from the device-dependent drivers are first placed into a ring buffer
      whose size is defined in the constructor and configuration function. The driver
      provides 4 current readings. 7 additional values are computed from these 4 values:
      SumX, SumY, SumAll, DiffX, DiffY, PositionX, PositionY. The meanings of X and Y
      are discussed in the geometry section below.</li>
    <li>The PV called AveragingTime determines the time period over which to average the
      readings. The AveragingTime divided by the SampleTime determines the number of samples
      to average, NumAverage_RBV. When this number of samples have been accumulated in
      the ring buffer a separate thread copies them to a set of NDArrays and calls any
      registered plugins. </li>
    <li>There is a separate NDPluginStats plugin loaded for each of the 11 data values.
      This plugin receives an array of dimensions [NumAverage_RBV]. This plugin computes
      not only the mean, but also the standard deviation, histogram of values, etc.</li>
    <li>One of the NDArrays contains all of the data values, and has dimensions [11,NumAverage_RBV].
      This array can be passed to any of the file writing plugins, which can thus stream
      all of the data to disk for arbitrarily long time periods. </li>
    <li>The [11,NumAverage_RBV] NDArray is also passed to the NDPluginTimeSeries plugin
      which is used to generate time-series arrays. </li>
    <li>The time-series plugin output is used by the NDPluginFFT plugin to compute FFTs,
      producing arrays containing the frequency power-spectrum of the time series data.</li>
    <li>An NDStdArrays plugin is also loaded. This can be used to pass all of the data
      [11,NumAverage_RBV] or any of the individual data arrays to any channel access client.</li>
    <li>The computationally intensive work of calculating the statistics is done in plugins,
      so can be done in different threads (if CallbacksBlock is set to No), each potentially
      running in a separate core on modern CPUs.</li>
    <li>In addition to placing the data from each time point into the ring buffer, the
      driver does callbacks on the asynFloat64 interface for each data value. This is
      typically used for fast feedback support with the epid record.</li>
  </ul>
  <p>
    Note: This version of the driver requires a minimum firmware version on some models</p>
  <ul>
    <li>AH501D Firmware version 2.0.</li>
    <li>TetrAMM Firmware version 2.9.11</li>
  </ul>
  <p>
    Prior to R5-0 the quadEM driver assumed the following geometry for the 4 current
    inputs:</p>
  <pre>
             4
             
          1     2
             
             3
  </pre>
  <p>
    The PV for the computed quantities were called Sum12, Sum34, Sum1234, Diff12, Diff34,
    Position12, and Position34. The differences, and hence positions, were computed
    as 2-1 and 4-3, which would correspond to Position12 being positive to the right
    and Position34 being positive up in the above diagram.</p>
  <p>
    For R5-0 and later two geometries are supported, and the names of the Sum, Diff
    and Position PVs were changed. The computed quantities are called SumX, SumY, SumAll,
    DiffX, DiffY, PositionX, and PositionY.</p>
  <p>
    The first geometry is the same as that illustrated above, and is called Diamond.
    For this geometry only 2 diodes are used for the position calculation in each direction.
    SumX=(1+2), SumY=(3+4), DiffX=(2-1), DiffY=(4-3). This geometry is identical to
    the geometry assumed prior to R5-0. The X diodes are 1&2 rather than 1&3 so that
    it is possible to use just the first 2 inputs on the AH501 series to increase readout
    speed in cases where all 4 diodes are not used. This would not be possible if diodes
    1 and 3 were used for the X calculations.</p>
  <p>
    The second geometry is:</p>
  <pre>

          1     2
       
             
          4     3
  </pre>
  <p>
    This geometry is called Square. For this geometry all 4 diodes are used for the
    position calculation in each direction. SumX=SumY=(1+2+3+4), DiffX=(2+3)-(1+4),
    DiffY=(1+2)-(3+4).</p>
  <p>
    For both geometries SumAll=(1+2+3+4), PositionX=DiffX/SumX, and PositionY=DiffY/SumY.
    X positive is to the right and Y positive is up for both geometries.</p>
  <h2 id="Databases">
    Databases</h2>
  <h3 id="quadEM">
    quadEM.template</h3>
  <p>
    The quadEM.template database provides control of the electrometer using the standard
    asyn device support. <a href="http://cars.uchicago.edu/software/epics/NDPluginStats.html">
      NDStats.template</a> from <a href="http://cars.uchicago.edu/software/epics/areaDetector.html">
        areaDetector</a> provides digitally averaged readings of the current, sum, difference
    and position with user-defined averaging time. It also provides the standard deviation,
    minimum, maximum, and other statistics, including a histogram of array values.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Records in quadEM.template</b></td>
      </tr>
      <tr>
        <th>
          drvInfo string</th>
        <th>
          EPICS record name</th>
        <th>
          EPICS record type</th>
        <th>
          asyn interface</th>
        <th>
          Access</th>
        <th>
          Models supported</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          QE_MODEL</td>
        <td>
          $(P)$(R)Model</td>
        <td>
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The model of the electrometer. This is normally determined automatically by the
          driver by reading the firmware version. It can also be specified in the configuration
          command. Values are:
          <ul>
            <li>0: Unknown</li>
            <li>1: APS_EM</li>
            <li>2: AH401B</li>
            <li>3: AH401D</li>
            <li>4: AH501</li>
            <li>5: AH501C</li>
            <li>6: AH501D</li>
            <li>7: TetrAMM</li>
            <li>8: NSLS_EM</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_FIRMWARE</td>
        <td>
          $(P)$(R)Firmware</td>
        <td>
          waveform</td>
        <td>
          asynOctet</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The firmware version of the electrometer. In R6-0 this was changed from a stringin
          record to a waveform record of length 256 because the TetrAMM firmware string is
          longer than 40 characters.</td>
      </tr>
      <tr>
        <td>
          QE_ACQUIRE_MODE</td>
        <td>
          $(P)$(R)AcquireMode<br />
          $(P)$(R)AcquireMode_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Acquire mode. Values are:
          <ul>
            <li>0: "Continuous" Acquires data continuously until Acquire is set back to 0.</li>
            <li>1: "Multiple" Acquires NumAcquire acquisitions and then automatically stops acquisition,
              setting Acquire back to 0.</li>
            <li>2: "Single" Acquires a single acquisition. This is a convenience, it is identical
              to Multiple with NumAcquire=1.</li>
          </ul>
          Multiple and Single mode are typically used for data acquisition. </td>
      </tr>
      <tr>
        <td>
          QE_ACQUIRE</td>
        <td>
          $(P)$(R)Acquire</td>
        <td>
          busy</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Acquire command. This command turns acquisition from the device on (1) and off (0)
          Since it is a "busy" record the device can be used for step-scanning with the sscan
          record when AcquireMode=Single<br />
          <b>Important note:</b> Operation in Single mode with the sscan record also requires
          that the statistics plugins be set to have CallbacksBlock=Yes so that the driver
          waits for the statistics plugins to compute before it sets Acquire back to 0.
        </td>
      </tr>
      <tr>
        <td>
          QE_READ_FORMAT</td>
        <td>
          $(P)$(R)ReadFormat<br />
          $(P)$(R)ReadFormat_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All except APS_EM and NSLS_EM</td>
        <td>
          Read format from the device. Values are:
          <ul>
            <li>0: Binary </li>
            <li>1: ASCII </li>
          </ul>
          In binary mode the AH401 and AH501 send integer data with no delimiters or terminators.
          This can lead to problems if the data stream is somehow corrupted because there
          is no way to know where one set of readings end and the next set begins. This should
          not happen under normal conditions because the devices use TCP, which guarantees
          retransmission of dropped packets. However, it has been observed to occur. In binary
          mode the TetrAMM sends IEEE 754 double-precision values for each channel, followed
          by a Signalling NaN. The NaN is thus effectively a terminator that can be used to
          synchronize the data stream if it is somehow corrupted. ASCII mode is robust against
          the synchronization problem, since each reading ends with terminator characters.
          However, ASCII mode is generally slower. On the AH401 ASCII mode appears to be able
          to do 500 reading/s, which is sufficient except for the case when IntegrationTime=.001
          and PingPong=Yes. On the AH501 ASCII mode ranges from 7 to 10 times slower than
          binary mode. On the TetrAMM ASCII mode requires a minimum value of ValuesPerRead
          of 500, which limits the update rate to 200 Hz. In binary mode the minimum value
          of ValuesPerRead is 5, which is an update date of 20 kHz, or 100 times faster than
          ASCII mode. </td>
      </tr>
      <tr>
        <td>
          QE_RANGE</td>
        <td>
          $(P)$(R)Range<br />
          $(P)$(R)Range_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Range command. This selects the sensitivity of the electrometer (A/D units per nanoamp).<br />
          For the TetrAMM the choices are:
          <ul>
            <li>&plusmn;120uA</li>
            <li>&plusmn;120nA</li>
          </ul>
          For the AH501 series the choices are:
          <ul>
            <li>&plusmn;2.5mA</li>
            <li>&plusmn;2.5uA</li>
            <li>&plusmn;2.5nA</li>
          </ul>
          For the AH401 series this selects the feedback capacitor, which controls the gain
          of the device. There are 8 capacitor choices in units of saturation charge:
          <ul>
            <li>1800 pC</li>
            <li>350 pC</li>
            <li>300 pC</li>
            <li>250 pC</li>
            <li>200 pC</li>
            <li>150 pC</li>
            <li>100 pC</li>
            <li>50 pC</li>
          </ul>
          For the NSLS_EM this selects the feedback capacitor, which controls the gain of
          the device. There are 8 capacitor choices in units of saturation charge:
          <ul>
            <li>350 pC</li>
            <li>300 pC</li>
            <li>250 pC</li>
            <li>200 pC</li>
            <li>150 pC</li>
            <li>100 pC</li>
            <li>50 pC</li>
            <li>12 pC</li>
          </ul>
          For the APS_EM this selects the feedback capacitor, which controls the gain of the
          device. There are 8 capacitor choices:
          <ul>
            <li>External</li>
            <li>17.6 pf</li>
            <li>8.80 pF</li>
            <li>5.87 pF</li>
            <li>4.40 pF</li>
            <li>3.52 pF</li>
            <li>2.93 pF</li>
            <li>2.51 pF</li>
          </ul>
          On the APS_EM all gains except the first External gain use capacitors that are built
          in to the Burr Brown chip. These are quite small capacitors and only cover a narrow
          range, so the gains are quite high, and only rather low currents can be measured
          with them, even at the shortest integration times. The external capacitors can be
          replaced to select the first gain, and boards are normally built with 220 pF external
          capacitors. At APS 13-ID we have used much larger values, 1000 to 5000 pF, because
          the currents from our undulator beam position monitor are large. There are actually
          8 external capacitors: 4 of them control the gain for each input for the "ping"
          channel, and the other 4 control the gain for the "pong" channel. By using one capacitor
          value for the 4 diodes on the ping channel and a different capacitor value for the
          4 diodes on the pong channel, then two user-selectable gains are available. One
          must then select the appropriate channel in the PingPong record, and not use the
          average.</td>
      </tr>
      <tr>
        <td>
          QE_PING_PONG</td>
        <td>
          $(P)$(R)PingPong<br />
          $(P)$(R)PingPong_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH401 series, NSLS_EM, APS_EM</td>
        <td>
          The AH401 series, NSLS_EM, and the APS_EM have 2 input channels, which we call Ping
          and Pong here. This doubles the speed of the unit, because one channel is being
          digitized while the other is integrating. This record selects how the two channels
          are treated.<br />
          On the AH401 series the choices are "Off" (0) and "On" (1). "Off" only returns the
          data from the Ping channel. This reduces noise because only a single integration
          capacitor is used, but it reduces the data rate by a factor of two, because data
          are only returned on every other integration time. "On" returns the data from both
          channels, which doubles the data rate at some expense in noise.<br />
          On the NSLS_EM and APS_EM both values are always transmitted from the device. On
          the APS_EM and the choices are #1 (Ping), #2 (Pong), and Avg. which averages the
          values from the Ping and Pong channels. Note that if Range=External and the two
          external capacitors are different, then one should not use Avg. because that will
          mix data from two different gains. On the NSLS_EM and the choices are Phase0, Phase1,
          and Both. These are really the same as the choices on the APS_EM, but using the
          nomenclature that the NSLS_EM documentation uses.</td>
      </tr>
      <tr>
        <td>
          QE_INTEGRATION_TIME</td>
        <td>
          $(P)$(R)IntegrationTime<br />
          $(P)$(R)IntegrationTime_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          AH401 series, NSLS_EM, APS_EM</td>
        <td>
          Selects the integration time of the amplifier. As the integration time is increased
          the sensitivity increases, but the number of readings/sec sent from the device is
          decreased.<br />
          For the AH401 series values range from 0.001s to 1.000s. The data are sent after
          one integration time if PingPong="On" or after 2 integration times if PingPong="Off".<br />
          For the NSLS_EM the values range from .0004s to 1.0 s. Both the Phase0 (Ping) and
          Phase1 (Pong) values are sent at after a time period equal to IntegrationTime *
          ValuesPerRead.<br />
          For the APS_EM the values range from .000615s to 0.1311s. The data are sent to the
          VME card from the amplifier after 2 integration times, one value in the Ping channel
          and one value in the Pong channel. The data period is thus 0.00123 to 0.02622 s,
          or a frequency range of about 813 Hz to 38.1 Hz. </td>
      </tr>
      <tr>
        <td>
          QE_NUM_CHANNELS</td>
        <td>
          $(P)$(R)NumChannels<br />
          $(P)$(R)NumChannels_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM and AH501 series</td>
        <td>
          Selects the number of channels to measure and transmit data for. Using fewer than
          4 channels increases the sampling rate. Allowed choices are:
          <ul>
            <li>1: channel 1 only</li>
            <li>2: channels 1 and 2 only</li>
            <li>4: channels 1-4</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_GEOMETRY</td>
        <td>
          $(P)$(R)Geometry<br />
          $(P)$(R)Geometry_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Selects the geometry of the current inputs as discussed above. Allowed choices are:
          <ul>
            <li>0: Diamond</li>
            <li>1: Square</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_RESOLUTION</td>
        <td>
          $(P)$(R)Resolution<br />
          $(P)$(R)Resolution_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          AH501 series</td>
        <td>
          Selects the resolution of the ADC in bits. Using 16-bits increases the sampling
          rate by a factor of 2 relative to 24-bits. Allowed choices are:
          <ul>
            <li>16: 16-bit data</li>
            <li>24: 24-bit data</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_STATE</td>
        <td>
          $(P)$(R)BiasState<br />
          $(P)$(R)BiasState_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501C and AH501D</td>
        <td>
          Selects the state of the bias supply output voltage. Allowed choices are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_HVS_READBACK</td>
        <td>
          $(P)$(R)HVSReadback</td>
        <td>
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual status of the bias supply output. Possible values are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
          This will stay On for a few seconds after setting BiasState to Off, while the voltage
          is ramped down to 0.</td>
      </tr>
      <tr>
        <td>
          QE_BIAS_INTERLOCK</td>
        <td>
          $(P)$(R)BiasInterlock<br />
          $(P)$(R)BiasInterlock_RBV</td>
        <td>
          bo<br />
          bi</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM</td>
        <td>
          Selects the state of the bias supply interlock. Allowed choices are:
          <ul>
            <li>0: Off</li>
            <li>1: On</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_BIAS_VOLTAGE</td>
        <td>
          $(P)$(R)BiasVoltage<br />
          $(P)$(R)BiasVoltage_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501C and AH501D</td>
        <td>
          Controls the voltage of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_HVV_READBACK</td>
        <td>
          $(P)$(R)HVVReadback</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual voltage of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_HVI_READBACK</td>
        <td>
          $(P)$(R)HVIReadback</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          TetrAMM</td>
        <td>
          Readback of the actual current in microamps of the bias supply output.</td>
      </tr>
      <tr>
        <td>
          QE_VALUES_PER_READ</td>
        <td>
          $(P)$(R)ValuesPerRead<br />
          $(P)$(R)ValuesPerRead_RBV</td>
        <td>
          longout<br />
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          On the TetrAMM this record controls the number of readings that are averaged in
          the TetrAMM using the NRSAMP command. The TetrAMM always digitizes at 100 kHz (10
          microseconds per sample). The minimum value of NRSAMP (and hence ValuesPerRead)
          in Binary mode is 5, which means the maximum number of values per second is 20000.
          Setting ValuesPerRead to 100, for example, will average 100 readings in the TetrAMM,
          and thus result in a 1000 values per second sent from the TetrAMM to EPICS.<br />
          <br />
          On the NSLS_EM this record controls the number of readings that are summed in the
          NSLS_EM using the "n" command.<br />
          <br />
          For all other models ValuesPerRead controls the number of values that are read from
          the meter in a single call. These values are averaged in the driver before it does
          any callbacks. The default is 1 (no averaging).
          <br />
          <br />
          Increasing ValuesPerRead will reduce the CPU time because:
          <ul>
            <li>On the TetrAMM it reduces the number of readings per second sent, from the maximum
              of 20000, to 100000/ValuesPerRead.</li>
            <li>On the NSLS_EM it reduces the number of readings per second sent, from the maximum
              of 2500 (depending on IntegrationTime, to a maximum of 2500/ValuesPerRead.</li>
            <li>On the AH401 and AH501 series the driver reduces the frequency of asynOctet-&gt;read()
              calls by a factor of ValuesPerRead, because it can obtain multiple readings from
              the meter in a single call. This is particularly significant on the AH501 series,
              which can transmit up to 26,040 readings per second.</li>
            <li>It reduces the frequency of callbacks to device support.</li>
          </ul>
          The potential disadvantages of larger values for ValuesPerRead are:
          <ul>
            <li>It will change the statistics computed by the NDPluginStats plugin because an
              initial averaging operation has already been performed, which reduces the standard
              deviation, changes the histogram, etc.</li>
            <li>On the NSLS_EM it prevents selecting only Phase0 or Phase1 with the PingPong record.</li>
            <li>It will reduce the sampling frequency of the TimeSeries support</li>
            <li>It will reduce the update frequency of the EPID fast feedback support.</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_SAMPLE_TIME</td>
        <td>
          $(P)$(R)SampleTime_RBV</td>
        <td>
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the actual time between sample readings from the device. This is controlled
          by the following parameters:
          <ul>
            <li>ValuesPerRead: All models</li>
            <li>IntegrationTime: AH401 series, NSLS_EM, and APS_EM</li>
            <li>PingPong: AH401 series and NSLS_EM</li>
            <li>NumChannels: AH501 series</li>
            <li>Resolution: AH501 series</li>
          </ul>
          The sample time on the TetrAMM is controlled by the following equation:
          <ul>
            <li>10 microseconds * ValuesPerRead.</li>
          </ul>
          The sample time on the AH501 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = 38.4 microseconds * NumChannels * ValuesPerRead</li>
            <li>If Resolution == 24 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time (NumChannels=1, ValuesPerRead=1, Resolution=16) is 38.4
          microseconds, or a sampling frequency of 26.04 kHz. The maximum sample time with
          ValuesPerRead=1, NumChannels=4, Resolution=24 is 307.2 microseconds, or a sampling
          frequency of 3.255 kHz. Setting ValuesPerRead &gt; 1 will increase the sample time
          and reduce the sampling frequency proportionally.<br />
          <br />
          The sample time on the AH401 series is controlled by the following algorithm:
          <ul>
            <li>SampleTime = IntegrationTime * ValuesPerRead</li>
            <li>If PingPong == 0 then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time is 0.001 seconds, or 1 kHz sampling frequency. The maximum
          sampling time (PingPong=0) is 2 seconds, or 0.5 Hz sampling frequency. Setting ValuesPerRead
          &gt; 1 will increase the sample time and reduce the sampling frequency proportionally.<br />
          <br />
          The sample time on the NSLS_EM is controlled by the following algorithm:
          <ul>
            <li>SampleTime = IntegrationTime * ValuesPerRead</li>
            <li>If PingPong != Both then SampleTime = SampleTime * 2</li>
          </ul>
          The minimum sample time is 0.00041 seconds, or 2.5 kHz sampling frequency. The maximum
          sampling time (PingPong!=Both) is 2 seconds, or 0.5 Hz sampling frequency. Setting
          ValuesPerRead &gt; 1 will increase the sample time and reduce the sampling frequency
          proportionally.<br />
          <br />
          For the APS_EM the sample time is controlled only by ValuesPerRead and the IntegrationTime.
          For ValuesPerRead=1 it ranges from 0.00123 to 0.02622 s, or a sampling frequency
          range of about 813 Hz to 38.1 Hz. Setting ValuesPerRead &gt; 1 will increase the
          sample time and reduce the sampling frequency proportionally.</td>
      </tr>
      <tr>
        <td>
          QE_AVERAGING_TIME</td>
        <td>
          $(P)$(R)AveragingTime<br />
          $(P)$(R)AveragingTime_RBV</td>
        <td>
          ao<br />
          ai</td>
        <td>
          asynFloat64</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Controls the time period over which values are accumulated in the ring buffer before
          they are read out into NDArray objects and any registered plugins are called. AveragingTime
          is actually used to compute NumAverage_RBV=AveragingTime/SampleTime_RBV. The callbacks
          are done when the number of values in the ring buffer equals NumAverage_RBV, and
          exactly NumAverage_RBV values will be passed to the plugins.<br />
          However, setting AveragingTime=0 will set NumAverage_RBV=0 as well, and will disable
          automatic callbacks to areaDetector plugins. In this case data will only be read
          from the ring buffer when the ReadData record is processed. This will read out all
          available data from ring buffer, and the actual number of values read will be NumAveraged_RBV.
          This mode could be useful when the quadEM is being used for data acquisition, for
          example in a scan. In this case processing the ReadData record will read all values
          that have accumulated in the ring buffer since ReadData was last processed. ReadData
          must be processed frequently enough to avoid ring-buffer overflow.</td>
      </tr>
      <tr>
        <td>
          QE_NUM_AVERAGE</td>
        <td>
          $(P)$(R)NumAverage_RBV</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the number of values that will be accumulated in the ring buffer before
          they are read out into NDArray objects and any registered plugins are called. NumAverage_RBV
          is computed as (int)((AveragingTime / SampleTime_RBV) + 0.5).
          <br />
          On the TetrAMM when TriggerMode=ExternalBulb the AveragingTime is ignored and NumAverage_RBV
          will be 0. The averaging is done on all samples collected when the external gate
          signal is asserted</td>
      </tr>
      <tr>
        <td>
          QE_NUM_AVERAGED</td>
        <td>
          $(P)$(R)NumAveraged_RBV</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Provides the number of values that were actually accumulated in the ring buffer
          before they were read out into NDArray objects and any registered plugins were called.
          If AveragingTime&gt;0 then NumAveraged_RBV will be the same as NumAverage_RBV. However,
          if AveragingTime=0. then NumAverage_RBV=0 and NumAveraged_RBV gives the actual number
          of values read from the ring buffer when the ReadData record was processed. This
          is also true on the TetrAMM when TriggerMode=ExternalBulb.</td>
      </tr>
      <tr>
        <td>
          QE_NUM_ACQUIRE</td>
        <td>
          $(P)$(R)NumAcquire
          <br />
          $(P)$(R)NumAcquire_RBV</td>
        <td>
          longout
          <br />
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          The number of acquisitions to acquire when AcquireMode=Multiple. An acquisition
          is complete when the callbacks are called. This normally occurs when the AveragingTime
          has elapsed. However when TriggerMode=Ext. Bulb then the callbacks are called and
          an acquisition is complete on the trailing edge of each external gate pulse.</td>
      </tr>
      <tr>
        <td>
          QE_NUM_ACQUIRED</td>
        <td>
          $(P)$(R)NumAcquired</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          The number of acquisitions completed since Acquire was set to 1.</td>
      </tr>
      <tr>
        <td>
          QE_READ_DATA</td>
        <td>
          $(P)$(R)ReadData</td>
        <td>
          busy</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          Writing 1 to this record reads all data from the ring buffer and does the NDArray
          callbacks to all registered plugins. This is typically done when the quadEM is being
          used for data acquisition, for example in a scan. In this case AveragingTime is
          set to 0 and processing the ReadData record will read all values that have accumulated
          in the ring buffer since ReadData was last processed.</td>
      </tr>
      <tr>
        <td>
          QE_RING_OVERFLOWS</td>
        <td>
          $(P)$(R)RingOverflows</td>
        <td>
          longin</td>
        <td>
          asynInt32</td>
        <td>
          r/o</td>
        <td>
          All</td>
        <td>
          It is possible for the ring buffer to overflow. The rate at which values are added
          to the ring buffer is controlled by SampleTime_RBV. The rate at which values are
          removed is determined by AveragingTime, or by the rate at which ReadData is processed
          if AveragingTime=0. The size of the ring buffer is determined by the ringBufferSize
          argument to the driver constructor. This defaults to 2048 if it is not specified
          in configuration command in the startup script. If the ring buffer is full when
          the driver tries to add a new value, then the oldest value in the buffer is discarded,
          the new value is added, and RingOverflows is incremented. RingOverflows is set to
          0 the next time the ring buffer is read out. </td>
      </tr>
      <tr>
        <td>
          QE_TRIGGER_MODE</td>
        <td>
          $(P)$(R)TriggerMode</td>
        <td>
          mbbo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          TetrAMM, AH501 and AH401 series</td>
        <td>
          Allowed choices are:
          <ul>
            <li>0: "Free Run" (all models). Ignores any external gate or trigger signal.</li>
            <li>1: "Software" (possible future choice for TetrAMM) This will trigger a single
              acquisition each time a software trigger command is sent.</li>
            <li>2: "Ext. Trigger" (AH401B, TetrAMM) This is an edge-sensitive trigger. On the
              TetrAMM this will collect samples for the AveragingTime and then wait for the next
              trigger.</li>
            <li>3: "Ext. Bulb" (AH501D, TetrAMM) This is a level-sensitive trigger. It acquires
              data while the external gate signal is asserted. On the trailing edge of the gate
              signal the callbacks will be called. In this mode the AveragingTime is ignored and
              the averaging is done for all samples received between the leading and trailing
              edge of a single gate pulse.</li>
            <li>4: "Ext. Gate" (TetrAMM) This is a level sensitive gate. It acquires data while
              the external gate signal is asserted. However, unlike Ext. Bulb the trailing edge
              of the gate signal is ignored, and the averaging is done for NumAverage_RBV samples
              as with Free Run mode. The difference is that the actual averaging time will be
              longer than AveragingTime, and is controlled by the duty cycle of the external gate
              pulse. If the external gate pulse is asserted 40% of the time, then the actual averaging
              time will be AveragingTime * 2.5</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          QE_RESET</td>
        <td>
          $(P)$(R)Reset</td>
        <td>
          bo</td>
        <td>
          asynInt32</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Reset command. Processing this record will reset the electrometer. On the APS_EM
          this operation takes about 1 second, and may be required to establish communication
          if the amplifier unit is power-cycled or disconnected and reconnected. On the TetrAMM
          this does a hardware reset of the device, which takes about 10 seconds. On all models
          this operation downloads all of the EPICS settings to the electrometer. The Reset
          reord must be processed if any electrometer is power-cycled without rebooting the
          EPICS IOC.</td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_NAME</td>
        <td>
          $(P)$(R)CurrentName[1-4]</td>
        <td>
          stringin</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          User-defined name to give each of the Current[1-4] inputs. </td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_OFFSET</td>
        <td>
          $(P)$(R)CurrentOffset[1-4]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-3)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from each reading when calculating the Current[1-4].
          The current is calculated as Current = Raw*CurrentScale - CurrentOffset, where Raw
          is the raw value from the device. </td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)ComputeCurrentOffset[1-4]</td>
        <td>
          calcout</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Processing this record will compute a new value of CurrentOffset that will set value
          of the current to 0 under the current conditions. It computes CurrentOffset(new)
          = Current[1-3]:MeanValue_RBV + CurrentOffset(old). This record is provided to convenience
          set the CurrentOffset when the input signal is 0. </td>
      </tr>
      <tr>
        <td>
          QE_CURRENT_SCALE</td>
        <td>
          $(P)$(R)CurrentScale[1-4]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-3)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Scale factor that each reading is multiplied by when calculating the Current[1-4].
          The current is calculated as Current = Raw*CurrentScale - CurrentOffset, where Raw
          is the raw value from the device. This record provides a way to convert the current
          readings into engineering units. All of the models except the TetrAMM transmit integer
          data. This is converted to double precision float for averaging and statistics.
          It is converted back to integer for the time series software, which requires integer
          data. The TetrAMM transmits double precision data in units of amps, so the values
          are typically between 1e-4 to 1e-12. It is convenient to use a CurrentScale of 1e9
          or 1e12, for example, so that the data are displayed in units of nano-amps or pico-amps.
          They are then reasonable sized integers, and the time series software can be used.
        </td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)CurrentPrec[1-4]</td>
        <td>
          mbbo</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Precision (# digits) to use to display the current for this channel. Choices are
          0-9. CurrentPrec1 also controls SumX and DiffX. CurrentPrec3 also controls SumY
          and DiffY. CurrentPrec2 also controls SumAll. Note that when using medm and other
          display clients it is necessary to close and re-open the quadEM screen for the displayed
          precision to be changed. This is a limitation of the Channel Access protocol which
          does not send monitor events when the precision is changed.</td>
      </tr>
      <tr>
        <td>
          QE_POSITION_OFFSET</td>
        <td>
          $(P)$(R)PositionOffset[X,Y]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Offset that will be subtracted from each reading when calculating the Position[X,Y].
          The position is calculated as Position = Diff/Sum * PositionScale - PositionOffset.
        </td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)ComputePosOffset[X,Y]</td>
        <td>
          calcout</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Processing this record will compute a new value of PositionOffset that will set
          value of the position to 0 under the current conditions. It computes PositionOffset(new)
          = Pos[X,Y]:MeanValue_RBV + PositionOffset(old). This record is provided to convenience
          set the PositionOffset when the position should be defined as 0. </td>
      </tr>
      <tr>
        <td>
          QE_POSITION_SCALE</td>
        <td>
          $(P)$(R)PositionScale[X,Y]</td>
        <td>
          ao</td>
        <td>
          asynFloat64 (addr=0-1)</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Scale that will be used when calculating the Position[X,Y]. The position is calculated
          as Position = Diff/Sum * PositionScale - PositionOffset.</td>
      </tr>
      <tr>
        <td>
          N.A.</td>
        <td>
          $(P)$(R)PositionPrec[X,Y]</td>
        <td>
          mbbo</td>
        <td>
          N.A.</td>
        <td>
          r/w</td>
        <td>
          All</td>
        <td>
          Precision (# digits) to use to display the position in X or Y. Choices are 0-9.
        </td>
      </tr>
    </tbody>
  </table>
  <h3 id="TetrAMMAcquisitionModes">
    TetrAMM Acquisition Modes</h3>
  <p>
    The TetrAMM can be used in 8 different acquisition modes, depending on the values
    of the TriggerMode and AcquireMode records. The following table describes these
    modes. Note that AcquireMode=Single is completely equivalent to AcquireMode=Multiple
    and NumAcquire=1, so the table does not list AcquireMode=Single.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="4">
          <b>TetrAMM Acquisition Modes</b></td>
      </tr>
      <tr>
        <th>
          TriggerMode</th>
        <th>
          AcquireMode</th>
        <th>
          Description</th>
        <th>
          TetrAMM commands</th>
      </tr>
      <tr>
        <td>
          Free Run</td>
        <td>
          Continuous</td>
        <td>
          Values are acquired continuously and are averaged each time the AveragingTime is
          reached. </td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:OFF</td>
      </tr>
      <tr>
        <td>
          Free Run</td>
        <td>
          Multiple</td>
        <td>
          Data is acquired for the AveragingTime. This is repeated NumAcquire times and then
          acquisition stops. The plugins will be called NumAcquire times, each time with NumAverage
          samples.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:OFF</td>
      </tr>
      <tr>
        <td>
          Ext. Trig.</td>
        <td>
          Continuous</td>
        <td>
          A fixed number of samples is acquired starting on each rising edge of the external
          trigger input. AveragingTime must be set to a value less than the time between trigger
          pulses.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=AveragingTime/1e5/ValuesPerRead, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Trig.</td>
        <td>
          Multiple</td>
        <td>
          A fixed number of samples is acquired starting on the first rising edge of the external
          trigger input. This repeats NumAcquire times and then acquisition stops. ValuesPerRead
          must be set to a value less than AveragingTime/1e5.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=AveragingTime*1e5/ValuesPerRead, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Bulb</td>
        <td>
          Continuous</td>
        <td>
          Samples are acquired while the external trigger input is asserted. On each trailing
          edge of the external trigger signal the plugins are called. ValuesPerRead must be
          set to a value less than (external trigger asserted time * 1e5). AveragingTime is
          ignored in this mode.</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Bulb</td>
        <td>
          Multiple</td>
        <td>
          Samples are acquired while the external trigger input is asserted. On each trailing
          edge of the external trigger signal the plugins are called. This is repeated NumAcquire
          times and then acquisition is stopped. ValuesPerRead must be set to a value less
          than (external trigger asserted time * 1e5). AveragingTime is ignored in this mode.
        </td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Gate</td>
        <td>
          Continuous</td>
        <td>
          Samples are acquired while the external trigger input is asserted. When NumAverage
          samples have been acquired the plugins are called. The actual averaging time between
          calling the plugins will be longer than AverageTime, and is controlled by the duty
          cycle of the external gate signal. The trailing edge of the gate pulse is ignored
          in this mode. ValuesPerRead must be set to a value less than (external trigger asserted
          time * 1e5).</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
      <tr>
        <td>
          Ext. Gate</td>
        <td>
          Multiple</td>
        <td>
          Samples are acquired while the external trigger input is asserted. When NumAverage
          samples have been acquired the plugins are called. The actual averaging time between
          calling the plugins will be longer than AverageTime, and is controlled by the duty
          cycle of the external gate signal. When the plugins have been called NumAcquire
          times then acquisition is stopped. Note that the actual number of gate pulses received
          will be &gt; NumAcquire, and is also controlled by the duty cycle of the external
          gate signal. The trailing edge of the gate pulse is ignored in this mode. ValuesPerRead
          must be set to a value less than (external trigger asserted time * 1e5).</td>
        <td>
          NRSAMP=ValuesPerRead, NAQ=0, TRG:ON</td>
      </tr>
    </tbody>
  </table>
  <p>
    This is the medm screen to control the quadEM with the records in quadEM.template.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM.adl</h3>
    <img alt="quadEM.png" src="quadEM.png" /></div>
  <h3 id="Plugins">
    Plugins</h3>
  <p>
    The example IOCs provided with quadEM load a file called commonPlugins.cmd, which
    loads the following set of plugins from the areaDetector module. For more information
    see the documentation in the links in the table below. Other plugins can also be
    loaded, for example the TIFF, HDF5 or Nexus file writing plugins, etc.</p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="3">
          <b>Plugins loaded by commonPlugins.cmd</b></td>
      </tr>
      <tr>
        <th>
          Plugin type</th>
        <th>
          Record prefixes</th>
        <th>
          Description</th>
      </tr>
      <tr>
        <td>
          <a href="NDPluginStats.html">NDPluginStats</a></td>
        <td>
          $(P)$(R)Current[1-4]:</td>
        <td>
          Statistics for the current values. The average value is $(P)$(R)Current[1-4]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginStats.html">NDPluginStats</a></td>
        <td>
          $(P)$(R)Sum[X,Y,All]:</td>
        <td>
          Statistics for the sum of currents 1+2, 3+4, and 1+2+3+4. The average value is $(P)$(R)Sum[X,Y,All]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginStats.html">NDPluginStats</a></td>
        <td>
          $(P)$(R)Diff[X,Y]:</td>
        <td>
          Statistics for the differences of current 2-1 and 4-3. The average value is $(P)$(R)Diff[X,Y]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginStats.html">NDPluginStats</a></td>
        <td>
          $(P)$(R)Pos[X,Y]:</td>
        <td>
          Statistics for the positions. The average value is $(P)$(R)Pos[X,Y]:MeanValue_RBV.
          Many other statistics are available, including the minimum, maximum, standard deviation,
          and histogram of values.</td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginStdArrays.html">NDPluginStdArrays</a></td>
        <td>
          $(P)$(R)image1:</td>
        <td>
          Plugin that receives NDArray callbacks of dimension [11,NumAveraged_RBV] and puts
          this data into an EPICS waveform record. This can be used to provide access to all
          of the data from quadEM to any Channel Access client.</td>
      </tr>
      <tr>
        <td>
          <a href="NDFileNetCDF.html">NDFileNetCDF</a></td>
        <td>
          $(P)$(R)netCDF1:</td>
        <td>
          Plugin that receives NDArray callbacks of dimension [11,NumAveraged_RBV] and writes
          this data into a netCDF file. This can be done in Single mode, writing one array
          per file. o It can also be done in Stream mode, which continuously appends arrays
          to a single netCDF file.</td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginTimeSeries.html">NDPluginTimeSeries</a></td>
        <td>
          $(P)$(R)TS:</td>
        <td>
          Plugin that receives NDArray callbacks of dimension [11,NumAveraged_RBV] and forms
          11 different time-series arrays. This plugin provides a time-history (like a digital
          scope) of the current, sum, difference and position at speeds up to 20000Hz (TetrAMM),
          6510 Hz (AH501 series), 1000Hz (AH401 series) or 813 Hz (APS_EM). The time per point
          can be greater than the sampling time, in which case it does averaging. The time
          series can operate in a fixed-length mode where acquisition stops after the specified
          number of time points have been collected. This mode is suited for data-acquisition
          applications, such as on-the-fly scanning. The time series plugin can also operate
          in a circular buffer mode with continuous acquisition and display of the most recent
          time points. This mode is suited for continuous monitoring. </td>
      </tr>
      <tr>
        <td>
          <a href="NDPluginFFT.html">NDPluginFFT</a></td>
        <td>
          $(P)$(R)FFT[1-11]:</td>
        <td>
          Plugin that receives the time-series arrays from the NDPluginTimeSeries plugin and
          computes the frequency power-spectrum of each signal. This plugin can also average
          the FFTs to improve the signal/noise ratio.</td>
      </tr>
    </tbody>
  </table>
  <p>
    Note that the first time the IOC is started all of the plugins will have EnableCallbacks=Disable.
    It is necessary to enable each of the plugins that will be used. The plugins will
    also initially start with CallbacksBlock=No. Setting CallbacksBlock=Yes can reduce
    CPU load on slow processors like the MVME2100 (see the performance tables below).
    The values of EnableCallbacks and CallbacksBlock are saved by autosave, and will
    be restored the next time the IOC is started.</p>
  <p>
    This is the medm screen for all of the plugins defined in commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      QECommonPlugins.adl</h3>
    <img alt="QECommonPlugins.png" src="QECommonPlugins.png" /></div>
  <p>
    This is the medm screen for the Current1: NDPluginStats plugin loaded by commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDStats.adl</h3>
    <img alt="QENDStats.png" src="QENDStats.png" /></div>
  <p>
    This is the medm screen for the netCDF1: NDFileNetCDF plugin loaded by commonPlugins.cmd.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDFileNetCDF.adl</h3>
    <img alt="QENetCDF.png" src="QENetCDF.png" /></div>
  <p>
    This is the medm screen to control the NDPluginTimeSeries plugin. In this example
    the time per point from the TetrAMM is 50 microseconds, and averaging time for the
    time series plugin is 1 millisecond, or 20 points. The plugin has 2000 time points,
    and is operating in circular buffer mode.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDPluginTimeSeries.adl</h3>
    <img alt="quadEM_TimeSeries.png" src="quadEM_TimeSeries.png" /></div>
  <p>
    This is a plot of the time series for Current 1. It shows the last 2 seconds of
    data in circular buffer mode.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDTimeSeriesPlot.adl</h3>
    <img alt="quadEM_TimeSeriesPlot.png" src="quadEM_TimeSeriesPlot.png" /></div>
  <p>
    This is a plot of the time series for the horizontal currents, sum, and position.
    It shows the last 2 seconds of data in circular buffer mode.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_plogAll.adl</h3>
    <img alt="quadEM_HorizontalTimeSeriesPlot.png" src="quadEM_HorizontalTimeSeriesPlot.png" /></div>
  <p>
    This is a plot of the FFT for Current 1. DC offset suppression is enabled and 10
    FFTs are being averaged to improve the signal/noise ratio.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      NDFFTFreqSpectrumPlot.adl</h3>
    <img alt="quadEM_NDFFTFreqSpectrumPlot.png" src="quadEM_NDFFTFreqSpectrumPlot.png" /></div>
  <p>
    This is an medm screen for control of all 11 FFT plugins.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      QEFFTPlugins.adl</h3>
    <img alt="QEFFTPlugins.png" src="QEFFTPlugins.png" /></div>
  <p>
    This is an medm screen that displays the FFTs of the Current, Sum, and Position
    for the time-series data above. 100 FFTs are being averaged to improve the signal/noise
    ratio.</p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      quadEM_plotAll.adl</h3>
    <img alt="quadEM_HorizontalFFTPlot.png" src="quadEM_HorizontalFFTPlot.png" /></div>
  <h3 id="fast_pid_control">
    fast_pid_control.db
  </h3>
  <p>
    The quadEM can be used to do fast feedback with the EPID record from the synApps
    "std" module. The EPID record will process at up to the SampleTime discussed above.
    The DT field of the EPID record controls the time between feedback calculations,
    and this is constrained to be an integer multiple N of the quadEM SampleTime. If
    N>1 then N samples are averaged for each feedback operation.
  </p>
  <p>
    This is the medm screen that controls the fast feedback of the pitch of the monochromator
    on APS beamline 13-ID. The readback and control PVs cannot be changed after iocInit.
    The update rate (SCAN rate of EPID record) only controls the rate at which the EPID
    record displays "snapshots" of the values of the input, output, and error. It does
    not affect the rate at which the feedback is actually being done, which is controlled
    by the DT field in the EPID record, can be much faster than the SCAN value.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_control.adl</h3>
    <img alt="quadEM_pid_control.png" src="quadEM_pid_control.png" /></div>
  <p>
    This is the medm screen that controls the PID parameters. These include the feedback
    coefficients KP, KI, and KD. The DT (delta time) field controls the rate at which
    the feedback is actually been run. In this case DT=68.0 ms, which is 55 times longer
    than the sampling time (1.23 ms), so 55 position readings are being averaged each
    time the feedback is run.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_parameters.adl</h3>
    <img alt="quadEM_pid_parameters.png" src="quadEM_pid_parameters.png" /></div>
  <p>
    This is an medm screen that displays the setpoint of the pitch of the monochromator
    (in red), and the actual readback from the quadEM (in blue). Note that the readback
    here is only the snapshot values from the EPID record. For full-speed readings of
    the readback the waveform records from the quadEM_TimeSeries.template database would
    be used.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      pid_plot_readback.adl</h3>
    <img alt="quadEM_plot_readback.png" src="quadEM_pid_plot_readback.png" /></div>
  <p>
    This is pid_fast.template, an example substitutions file. This example uses a quadEM
    asyn port driver named "APS_EM". ICHAN is set to read from addr=9 and 10, which
    are the two position values of the quadEM driver. The INPUT_DATA and INPUT_INTERVAL
    strings are the drvInfo strings for these parameters in the driver. The output is
    sent to an asyn port driver named DAC1, which is a dac128V 12-bit A/D converter
    in this data. OCHAN is set to write to addr=1 and 2, which are the second and third
    DAC channels on that card. The OUTPUT_DATA string is the drvInfo string for the
    double precision data in the dac128V.
  </p>
  <pre>
file "$(STD)/stdApp/Db/fast_pid_control.db"
{
pattern
{P,                 PID,  INPUT,     INPUT_DATA,   INPUT_INTERVAL, ICHAN, OUTPUT, OCHAN,  OUTPUT_DATA,    LOPR,     HOPR,  DRVL,  DRVH,  PREC,   KP,    KI,  KD,   DT,        SCAN}
{quadEMTest:, MonoPitch, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,     9,   DAC1,     1,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
{quadEMTest:,  MonoRoll, APS_EM, QE_DOUBLE_DATA,   QE_SAMPLE_TIME,    10,   DAC1,     2,  DOUBLE_DATA,  -32767,    32767,     0,  4095,     3,  .02,  100.,  0., .001, ".1 second"}
}
</pre>
  <h2 id="Performance">
    Performance</h2>
  <h3>
    AH401B</h3>
  <p>
    The following table shows the CPU utilization of a Linux machine (Xeon E5630 2.53GHz,
    8 cores), and vxWorks MVME5100, with the AH401B electometer. The CPU load was measured
    under the following conditions. This is the maximum data rate of the AH401B and
    the time series waveform records and FFTs are processing at 1 Hz.</p>
  <ul>
    <li>ValuesPerRead=1</li>
    <li>IntegrationTime=0.001</li>
    <li>PingPoing=Yes</li>
    <li>AveragingTime=0.1</li>
    <li>NumChannels=4</li>
    <li>ReadFormat=Binary4</li>
    <li>Time series plugin
      <ul>
        <li>Plugin enabled</li>
        <li>TSNumPoints=2048</li>
        <li>TSAveragingTime=0.001</li>
        <li>TSRead.SCAN=1 second</li>
        <li>TSAcquireMode=Circular Buffer</li>
      </ul>
    </li>
    <li>FFT plugins enabled</li>
  </ul>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Performance of AH401B</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          6%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          15%</td>
      </tr>
    </tbody>
  </table>
  <p>
    It can be seen that the load on the Linux machine is only 6% of a single core, while
    the load on the MVME5100 is 15%.
  </p>
  <h3>
    TetrAMM</h3>
  <p>
    The following table shows the CPU utilization of the Linux machine and vxWorks MVME5100,
    with the TetrAMM electometer. The CPU load was measured under the following conditions.
    ValuesPerRead=5 is the maximum data rate of the AH401B and the time series waveform
    records and FFTs are processing at 1 Hz.</p>
  <ul>
    <li>ValuesPerRead=5, 10, 20, 50, 100</li>
    <li>AveragingTime=0.1</li>
    <li>NumChannels=4</li>
    <li>ReadFormat=Binary4</li>
    <li>Time series plugin
      <ul>
        <li>Plugin enabled</li>
        <li>TSNumPoints=2048</li>
        <li>TSAveragingTime=0.001</li>
        <li>TSRead.SCAN=1 second</li>
        <li>TSAcquireMode=Circular Buffer</li>
      </ul>
    </li>
    <li>FFT plugins enabled</li>
  </ul>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: right">
    <tbody>
      <tr>
        <td align="center" colspan="7">
          <b>Performance of TetrAMM</b></td>
      </tr>
      <tr>
        <th>
          System</th>
        <th>
          ValuesPerRead</th>
        <th>
          %CPU time</th>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          5</td>
        <td>
          14%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          10</td>
        <td>
          9%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          20</td>
        <td>
          6%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          50</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          Linux Xeon</td>
        <td>
          100</td>
        <td>
          4%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          5</td>
        <td>
          100%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          10</td>
        <td>
          49%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          20</td>
        <td>
          22%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          50</td>
        <td>
          11%</td>
      </tr>
      <tr>
        <td>
          MVME5100</td>
        <td>
          100</td>
        <td>
          5%</td>
      </tr>
    </tbody>
  </table>
  <p>
    It can be seen that the worst-case load on the Linux machine is only 14% of a single
    core, while the load on the MVME5100 is 100% when ValuesPerRead=5. Using ValuesPerRead=20
    or greater uses less than 22% of the CPU on the MVME5100, which is probably reasonable
    in practice. That value still produces 5 kHz updates for time-series and fast feedback.
  </p>
  <h2 id="Common_Setup">
    Common Setup</h2>
  <p>
    All of the device-dependent startup scripts invoke <a href="quadEM_commonPlugins_cmd.html">
      quadEM/iocBoot/commonPlugins.cmd</a>. This file can be edited to add additional
    plugins, such as the TIFF, HDF5, or Nexus file writers, etc.</p>
  <p>
    Each iocBoot/iocXXX directory, e.g. iocBoot/iocTetrAMM, contains an example startup
    script for Linux and Windows (st.cmd) and another for vxWorks (st.cmd.vxWorks).
    Each of these startup scripts invokes the device-dependent startup script(s), e.g.
    TetrAMM.cmd, NSLS_EM.cmd, etc.
  </p>
  <h2 id="TetrAMM_Setup">
    TetrAMM Setup</h2>
  <p>
    These meters communicate via IP, so they must be configured with an IP address reachable
    from the host IOC machine. The CAEN ELS Device Manager software must be used to
    configure the device IP address and port number.</p>
  <p>
    An example startup script is provided in
    <br />
    <a href="quadEM_cmd_TetrAMM.html">quadEM/iocBoot/iocTetrAMM/TetraAMM.cmd</a>
  </p>
  <p>
    This will need to be edited to set the correct IP address of the meter to be used.</p>
  <h2 id="AHxxx_Setup">
    AH401 and AH501 Series Setup</h2>
  <p>
    These meters communicate via IP, so they must be configured with an IP address reachable
    from the host IOC machine. The Lantronix module in the meters can be configured
    to use either UDP or TCP. UDP can reduce CPU load, however it is more susceptible
    to synchronization problems since it does not retransmit dropped packets. The startup
    script must include the UDP qualifier on the drvAsynIPPortConfigure command if UDP
    is selected.</p>
  <p>
    Example startup scripts are provided in
    <br />
    <a href="quadEM_cmd_AH401B.html">quadEM/iocBoot/iocAH401B/AH401B.cmd</a> and
    <br />
    <a href="quadEM_cmd_AH501.html">quadEM/iocBoot/iocAH501/AH501.cmd</a>
  </p>
  <p>
    These will need to be edited to set the correct IP address of the meters to be used.</p>
  <p>
    These scripts each invoke a generic script:
    <br />
    <a href="quadEM_cmd_AHxxx.html">quadEM/iocBoot/AHxxx.cmd</a>.
  </p>
  <h2 id="NSLS_EM_Setup">
    NSLS_EM Setup</h2>
  <p>
    These meters communicate via IP. They only support DHCP, they cannot be given a
    static IP address. Each module on the subnet must have a unique Module ID, which
    is set by a 16-position rotary switch on the device front panel. The driver sends
    a broadcast message on the subnet to determine the Module ID and current IP address
    of all NSLS_EM modules. If the specified module ID is found then it configures communication
    to that module by calling drvAsynIPPortConfigure internally.</p>
  <p>
    An example startup script is provided in
    <br />
    <a href="quadEM_cmd_NSLS_EM.html">quadEM/iocBoot/iocNSLS_EM/NSLS_EM.cmd</a>
  </p>
  <p>
    This will need to be edited to set the broadcast address of the network the device
    is connected to, and the Module ID of the device.</p>
  <h2 id="APS_EM_Setup">
    APS Electrometer Setup</h2>
  <p>
    The APS_EM VME card cannot generate interrupts, but it can output a TTL pulse each
    time new data is available, at up to 815 Hz. If this pulse is input to an Ip-Unidig
    (or other asyn digital I/O device with interrupt and callback capabilities), then
    the ipUnidig interrupt routine will call the APS_EM driver each time new data is
    available. The Ip-Unidig channel where the APS_EM pulse is connected is specified
    in the unidigChan argument to drvAPS_EMConfigure command in the startup script.
    If an Ip-Unidig or other interrupt source is not being used then the APS_EM driver
    will poll for new data at the system clock rate, typically 60Hz.</p>
  <p>
    An example startup script is provided in
    <br />
    <a href="quadEM_cmd_APS_EM.html">quadEM/iocBoot/iocAPS_EM/APS_EM.cmd</a>.<br />
    and
    <br />
    <a href="quadEM_st_cmd_vxWorks.html">quadEM/iocBoot/iocAPS_EM/st.cmd.vxWorks</a>.
  </p>
</body>
</html>
